#! /usr/bin/env bash

#
# image-resize – script for manage free space in the OS-image
# Copyright 2018-2020 Artem Smirnov @urpylka
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -e # Exit immidiately on non-zero result

echo_bold() {
    # TEMPLATE: echo_bold <TEXT> <TYPE>
    # TYPE: SUCCESS, ERROR, INFO

    # More info there https://www.shellhacks.com/ru/bash-colors/

    TEXT="$1"
    TEXT="\e[1m$TEXT\e[0m" # BOLD

    case "$2" in
        SUCCESS)
        TEXT="\e[32m${TEXT}\e[0m";; # GREEN
        ERROR)
        TEXT="\e[31m${TEXT}\e[0m";; # RED
        *)
        TEXT="\e[34m${TEXT}\e[0m";; # BLUE
    esac
    echo -e ${TEXT}
}

my_travis_retry() {
    # https://gist.github.com/letmaik/caa0f6cc4375cbfcc1ff26bd4530c2a3
    # https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/templates/header.sh

    local result=0
    local count=1

    while [ $count -le 3 ]; do
        [ $result -ne 0 ] && {
        echo -e "\n${ANSI_RED}The command \"$@\" failed. Retrying, $count of 3.${ANSI_RESET}\n" >&2
        }
        # ! { } ignores set -e, see https://stackoverflow.com/a/4073372
        ! { "$@"; result=$?; }
        [ $result -eq 0 ] && break
        count=$(($count + 1))
        sleep 1
    done

    [ $count -gt 3 ] && echo -e "\n${ANSI_RED}The command \"$@\" failed 3 times.${ANSI_RESET}\n" >&2
    return $result
}

umount_system() {
    # TEMPLATE: umount_system <MOUNT_POINT> <DEV_IMAGE>

    echo_bold "Unmount chroot rootfs and boot partition: $1"
    my_travis_retry umount -fR $1
    losetup -d $2
}

fix_partuuid() {
    local IMAGE_PATH=$1
    local OLD_DISKID=$2

    echo_bold "Mount loop-image: $IMAGE_PATH"
    local DEV_IMAGE=$(losetup -Pf $IMAGE_PATH --show)
    sleep 0.5

    local MOUNT_POINT=$(mktemp -d --suffix=.img-tool)
    echo_bold "Mount dirs ${MOUNT_POINT} & ${MOUNT_POINT}/boot"
    mount "${DEV_IMAGE}p2" ${MOUNT_POINT}
    mount "${DEV_IMAGE}p1" ${MOUNT_POINT}/boot

    # https://github.com/RPi-Distro/raspi-config/blob/master/init_resize.sh
    DISKID="$(fdisk -l "$IMAGE_PATH" | sed -n 's/Disk identifier: 0x\([^ ]*\)/\1/p')"
    sed -i "s/${OLD_DISKID}/${DISKID}/g" ${MOUNT_POINT}/etc/fstab
    sed -i "s/${OLD_DISKID}/${DISKID}/" ${MOUNT_POINT}/boot/cmdline.txt

    # Another method to change partuuid
    #sed -i 's/root=[^ ]*/root=\/dev\/mmcblk0p2/' /boot/cmdline.txt
    #sed -i 's/.*  \/boot           vfat    defaults          0       2$/\/dev\/mmcblk0p1  \/boot           vfat    defaults          0       2/' /etc/fstab
    #sed -i 's/.*  \/               ext4    defaults,noatime  0       1$/\/dev\/mmcblk0p2  \/               ext4    defaults,noatime  0       1/' /etc/fstab

    umount_system ${MOUNT_POINT} ${DEV_IMAGE}
}

IMG_PATH=$1
NEW_IMG_SIZE=$2

[ -f $IMG_PATH ] || (echo_bold "Enter the correct filepath!" "ERROR"; exit 1)

# TODO: Check OS and current software
# For example check macOS

FDISK_INFO=$(fdisk -l "$IMG_PATH") #&& echo -e "$FDISK_INFO"
# https://raspberrypi.stackexchange.com/questions/13137/how-can-i-mount-a-raspberry-pi-linux-distro-image
# Or we can use: "parted -m $IMG_PATH unit B print free", but it have not DISKID
# https://ru.wikipedia.org/wiki/Разрежённый_файл

CUR_DISKID=$(echo -e "$FDISK_INFO" | sed -n 's/Disk identifier: 0x\([^ ]*\)/\1/p')

LINUX_PART=$(echo -e "$FDISK_INFO" | tail -1 | grep Linux)
[[ -z $LINUX_PART ]] && (echo_bold "Linux partition is not at the end!" "ERROR"; exit 1)
LINUX_PART_START=$(($(echo $LINUX_PART | awk -F' ' '{ print $2 }') * 512))
LINUX_PART_END=$(($(echo $LINUX_PART | awk -F' ' '{ print $3 }') * 512))

# Можно делать луп на 2ю партицию просто используя "${LOOPBACK}p2",
# но тут проверочки и другие полезные данные
LOOPBACK=`losetup -f --show -o "$LINUX_PART_START" "$IMG_PATH"`
# https://www.stableit.ru/2011/05/losetup.html
# -f     : losetup сам выбрал loop (минуя занятые)
# -P     : losetup монтирует разделы в образе как отдельные подразделы,
#          например /dev/loop0p1 и /dev/loop0p2
# --show : печатает имя устройства, например /dev/loop4
# ======================================================================
# losetup can return smhtn like that ↓
# losetup: os.img: Warning: file does not fit into a 512-byte sector; the end of the file will be ignored.
# Change image size to 512B diveded size
# https://stackoverflow.com/questions/26540693/how-do-i-read-write-a-block-device

# set +e
e2fsck -fy -v $LOOPBACK &> /dev/null
# set -e

LINUX_PART_MIN_SIZE=$(( $(resize2fs -P $LOOPBACK 2> /dev/null | awk -F': ' '{ print $2 }') * 4096 ))
losetup -d "$LOOPBACK"

IMG_MIN_SIZE=$(($LINUX_PART_START + $LINUX_PART_MIN_SIZE + 512))
CUR_IMG_SIZE=$(($LINUX_PART_END + 512))
OBJ_IMG_SIZE=`du -sb $IMG_PATH | awk -F' ' '{ print $1 }'` # https://prowebmastering.ru/linux-uznat-razmer-papok-i-failov-v-terminale.html

echo "IMG_MIN_SIZE: $IMG_MIN_SIZE"
echo "CUR_IMG_SIZE: $CUR_IMG_SIZE"
echo "OBJ_IMG_SIZE: $OBJ_IMG_SIZE"

if [[ -n $NEW_IMG_SIZE ]]; then
    # FIXED:
    # losetup: os.img: Warning: file does not fit into a 512-byte sector; the end of the file will be ignored.
    DIVREMAINDER=$((${NEW_IMG_SIZE} % 512))
    if [[ $DIVREMAINDER -gt 0 ]]; then
        echo_bold "The NEW_IMG_SIZE ($NEW_IMG_SIZE) does not fit in 512-byte sector (logic of losetup utility), autocorrect size." "BLUE"
        NEW_IMG_SIZE=$(($NEW_IMG_SIZE + 512 - $DIVREMAINDER))
    fi

    LINUX_PART_NEW_SIZE=$(($NEW_IMG_SIZE - $LINUX_PART_START - 512))
    echo "LINUX_PART_NEW_SIZE: $LINUX_PART_NEW_SIZE"
    # Кажется можно и не делать дробные сектора для увеличения размера раздела,
    # но ввиду нестабильности и постоянных статических ошибок,
    # а также для унификации кода сделал перерасчет LINUX_PART_NEW_SIZE и NEW_IMG_SIZE
    # с учетом 4096-байтового сектора в LINUX_PART
    DIVREMAINDER2=$((${LINUX_PART_NEW_SIZE} % 4096))
    if [[ $DIVREMAINDER2 -gt 0 ]]; then
        echo_bold "The LINUX_PART_NEW_SIZE ($LINUX_PART_NEW_SIZE) does not fit in 4096-byte sector (logic of resize2fs utility), autocorrect size. And NEW_IMG_SIZE ($NEW_IMG_SIZE) too." "BLUE"
        LINUX_PART_NEW_SIZE=$(($LINUX_PART_NEW_SIZE + 4096 - $DIVREMAINDER2))
        NEW_IMG_SIZE=$(($LINUX_PART_START + $LINUX_PART_NEW_SIZE + 512))
    fi
    LINUX_PART_NEW_END=$(($LINUX_PART_START + $LINUX_PART_NEW_SIZE))

    echo "NEW_IMG_SIZE: $NEW_IMG_SIZE"
    echo "LINUX_PART_NEW_SIZE: $LINUX_PART_NEW_SIZE"
    echo "LINUX_PART_NEW_END: $LINUX_PART_NEW_END"

    # https://andreyex.ru/operacionnaya-sistema-linux/kak-sravnivat-chisla-v-bash
    [[ $NEW_IMG_SIZE -lt $IMG_MIN_SIZE ]] && (echo_bold "The image size cannot be less then $IMG_MIN_SIZE" "ERROR"; exit 1)
    [[ $NEW_IMG_SIZE -eq $CUR_IMG_SIZE ]] && (echo_bold "Nothing to do" "SUCCESS"; exit 1)

    # https://blog.eaglenn.ru/izmenenie-razmera-razdela-ext2-ext3-ext4-bez-poteri-informatsii/
    if [[ $NEW_IMG_SIZE -lt $CUR_IMG_SIZE ]]; then
        echo "MIN"

        LOOPBACK=$(losetup -Pf $IMG_PATH --show)
        resize2fs ${LOOPBACK}p2 $((LINUX_PART_NEW_SIZE / 4096))
        # Можно добавить параметр "-p" для отслеживания того, что делает программа.
        # Больше о параметрах здесь: http://man7.org/linux/man-pages/man8/resize2fs.8.html
        # Последним параметром указывается размер раздела,
        # если параметр не указан, то раздел увеличивается до последнего сектора устройства.

        sleep 1
        losetup -d $LOOPBACK

        parted $IMG_PATH rm 2
        parted $IMG_PATH unit B mkpart primary $LINUX_PART_START $LINUX_PART_NEW_END

        # https://linux.die.net/man/1/truncate
        truncate -s $(($LINUX_PART_NEW_END + 512)) $IMG_PATH
    else
        echo "MAX"

        truncate -s$NEW_IMG_SIZE $IMG_PATH

        parted $IMG_PATH rm 2
        parted $IMG_PATH unit B mkpart primary $LINUX_PART_START $LINUX_PART_NEW_END

        LOOPBACK=$(losetup -Pf $IMG_PATH --show)

        resize2fs ${LOOPBACK}p2 $((LINUX_PART_NEW_SIZE / 4096))
        sleep 1
        losetup -d $LOOPBACK
    fi

    # More information
    echo "================================================================================"
    parted -m $IMG_PATH unit B print free
    echo "================================================================================"

    fix_partuuid $IMG_PATH $CUR_DISKID
fi
