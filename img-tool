#! /usr/bin/env bash

#
# img-tool – script for executing commands in file-image,
# coping files, managing free space in the OS-image
#
# Copyright 2018-2020 Artem Smirnov urpylka@gmail.com
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -e # Exit immidiately on non-zero result

my_echo() {
  # TEMPLATE: my_echo <TEXT> <COLOR> <MOVE_CARRIER>
  # COLOR: GREEN, RED, BLUE

  # More info there https://www.shellhacks.com/ru/bash-colors/

  local TEXT=${1}
  # TEXT="$(date '+[%Y-%m-%d %H:%M:%S]') ${TEXT}"
  TEXT="\e[1m${TEXT}\e[0m" # BOLD

  case "$2" in
    GREEN)
    TEXT="\e[32m${TEXT}\e[0m";; # GREEN
    RED)
    TEXT="\a\e[31m${TEXT}\e[0m";; # RED
    BLUE)
    TEXT="\e[34m${TEXT}\e[0m";; # BLUE
  esac

  # TEXT="\a${TEXT}" # SOUND

  if [ ! -z $3 ]; then
    echo -ne ${TEXT}
  else
    echo -e ${TEXT}
  fi
}

# https://gist.github.com/letmaik/caa0f6cc4375cbfcc1ff26bd4530c2a3
# https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/templates/header.sh
travis_retry() {
  local result=0
  local count=1
  while [ $count -le 3 ]; do
    [ $result -ne 0 ] && {
      echo -e "\n${ANSI_RED}The command \"$@\" failed. Retrying, $count of 3.${ANSI_RESET}\n" >&2
    }
    # ! { } ignores set -e, see https://stackoverflow.com/a/4073372
    ! { "$@"; result=$?; }
    [ $result -eq 0 ] && break
    count=$(($count + 1))
    sleep 1
  done

  [ $count -gt 3 ] && {
    echo -e "\n${ANSI_RED}The command \"$@\" failed 3 times.${ANSI_RESET}\n" >&2
  }

  return $result
}

get_info() {
  local IMG_PATH=$1
  local FDISK=$(fdisk -l ${IMG_PATH} || (my_echo "fdisk error" "RED"; exit 1;))

  DISK_ID=$(echo -e "${FDISK}" | sed -n 's/Disk identifier: 0x\([^ ]*\)/\1/p')
  local PARTS=$(echo -e "${FDISK}" | awk 'FNR>8')
  PARTS_COUNT=$(echo -e "${PARTS}" | wc -l)

  if [[ "${PARTS_COUNT}" != 1 && "${PARTS_COUNT}" != 2 ]] ; then
    my_echo "Image is incorrect" "RED"; exit 1;
  fi

  local PART1=$(echo -e "${PARTS}" | awk 'FNR==1')
  local PART2=$(echo -e "${PARTS}" | awk 'FNR==2')

  PART1_TYPE=$(echo ${PART1} | awk -F' ' '{print $7}')
  PART1_START=$(echo ${PART1} | awk -F' ' '{print $2}')
  PART1_SIZE=$(echo ${PART1} | awk -F' ' '{print $4}')

  PART2_TYPE=$(echo ${PART2} | awk -F' ' '{print $7}')
  PART2_START=$(echo ${PART2} | awk -F' ' '{print $2}')
  PART2_SIZE=$(echo ${PART2} | awk -F' ' '{print $4}')
}

mount_image() {
  # TEMPLATE: mount_image <IMG_PATH> <FUNCTION> [...]
  # <IMG_PATH> may be image file or block device
  # mount_image is executing function from arguments
  # <FUNCTION> <MOUNT_POINT> [...]

  local IMG_PATH=$1
  local MOUNT_POINT=$(mktemp -d --suffix=.img-tool)

  # what is IMG_PATH
  case `file ${IMG_PATH} | awk -F ': ' '{print $2}'` in
    block\ special*)
      local FILE_TYPE=block
      local DEV_IMAGE=${IMG_PATH};;

    DOS/MBR\ boot\ sector*)
      local FILE_TYPE=file
      local DEV_IMAGE=$(losetup -f)
      losetup ${DEV_IMAGE} ${IMG_PATH} || (my_echo "losetup error" "RED"; exit 1;)
      sleep 0.5;;

    *)
      my_echo "IMG_PATH incorrect" "RED"; exit 1;;
  esac

  # what king this image: raspbian, armbian
  # filesystem / architecture
  get_info ${IMG_PATH}

  case ${PARTS_COUNT} in
    1)
      my_echo "One partition temporary doesn't support" "RED"; exit 1
      ;;
    2)
      if [[ ${PART1_TYPE} == "W95" && ${PART2_TYPE} == "Linux" ]]; then

        PART1_START=$((${PART1_START}*512))
        PART1_SIZE=$((${PART1_SIZE}*512))
        PART2_START=$((${PART2_START}*512))
        PART2_SIZE=$((${PART2_SIZE}*512))

        # https://linux.die.net/man/8/mount
        mount -t ext4 -o offset=${PART2_START},sizelimit=${PART2_SIZE} ${DEV_IMAGE} ${MOUNT_POINT}
        mount -t vfat -o offset=${PART1_START},sizelimit=${PART1_SIZE} ${DEV_IMAGE} ${MOUNT_POINT}/boot

        local IMG_TYPE="Raspbian"
      else
        my_echo "Incorrect scheme of partitions" "RED"; exit 1
      fi
      ;;
    *)
      my_echo "Incorrect scheme of partitions" "RED"; exit 1
      ;;
  esac

  if [[ -z ${2} ]]; then
    my_echo "The function isn't setted" "RED"
    local RET=1
  else
    ${2} ${MOUNT_POINT} ${@:3}
    local RET=$?
  fi

  my_echo "Unmount chroot rootfs and boot partition: ${MOUNT_POINT}" "BLUE"
  travis_retry umount -fl ${MOUNT_POINT}
  losetup -d ${DEV_IMAGE}

  exit ${RET}
}

fix_partuuid() {
    # TEMPLATE: fix_partuuid <MOUNT_POINT> <IMAGE_PATH> <OLD_DISKID>
    local MOUNT_POINT=$1
    local IMAGE_PATH=$2
    local OLD_DISKID=$3

    # https://github.com/RPi-Distro/raspi-config/blob/master/init_resize.sh
    local DISKID="$(fdisk -l "${IMAGE_PATH}" | sed -n 's/Disk identifier: 0x\([^ ]*\)/\1/p')"
    sed -i "s/${OLD_DISKID}/${DISKID}/g" ${MOUNT_POINT}/etc/fstab
    sed -i "s/${OLD_DISKID}/${DISKID}/" ${MOUNT_POINT}/boot/cmdline.txt

    # Another method to change partuuid
    #sed -i 's/root=[^ ]*/root=\/dev\/mmcblk0p2/' /boot/cmdline.txt
    #sed -i 's/.*  \/boot           vfat    defaults          0       2$/\/dev\/mmcblk0p1  \/boot           vfat    defaults          0       2/' /etc/fstab
    #sed -i 's/.*  \/               ext4    defaults,noatime  0       1$/\/dev\/mmcblk0p2  \/               ext4    defaults,noatime  0       1/' /etc/fstab
}

add_settings() {
  # TEMPLATE: add_settings <MOUNT_POINT>

  local REGISTER=':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-wrapper:'
  if [[ $(arch) != 'armv7l' ]]; then
    my_echo "Enable qemu-arm-static"
    mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc 2> /dev/null || true
    echo ${REGISTER} > /proc/sys/fs/binfmt_misc/register 2> /dev/null || true
    cp '/usr/share/qemu-wrapper' "${MOUNT_POINT}/usr/bin/qemu-wrapper"
    cp '/usr/share/qemu-arm-static' "${MOUNT_POINT}/usr/bin/qemu-arm-static"
  else my_echo "qemu-arm-static is not need"
  fi

  my_echo "Bind system dirs"

  my_echo "Mounting /proc in chroot... " "BLUE" 1
  if [ ! -d ${MOUNT_POINT}/proc ]; then
    mkdir -p ${MOUNT_POINT}/proc; fi
  mount -t proc -o nosuid,noexec,nodev proc ${MOUNT_POINT}/proc \
  && my_echo "OK" "GREEN" \
  || (my_echo "Failed" "RED"; exit 1)

  my_echo "Mounting /sys in chroot... " "BLUE" 1
  if [ ! -d ${MOUNT_POINT}/sys ]; then
    mkdir -p ${MOUNT_POINT}/sys; fi
  mount -t sysfs -o nosuid,noexec,nodev sysfs ${MOUNT_POINT}/sys \
  && my_echo "OK" "GREEN" \
  || (my_echo "Failed" "RED"; exit 1)

  my_echo "Mounting /dev/ and /dev/pts in chroot... " "BLUE" 1 \
  && mkdir -p -m 755 ${MOUNT_POINT}/dev/pts \
  && mount -t devtmpfs -o mode=0755,nosuid devtmpfs ${MOUNT_POINT}/dev \
  && mount -t devpts -o gid=5,mode=620 devpts ${MOUNT_POINT}/dev/pts \
  && my_echo "OK" "GREEN" \
  || (my_echo "Failed" "RED"; exit 1)

  my_echo "Copy DNS records "  "BLUE" 1 \
  && cp -L /etc/resolv.conf ${MOUNT_POINT}/etc/resolv.conf \
  && my_echo "OK" "GREEN" \
  || (my_echo "Failed" "RED"; exit 1)
}

exec() {
  # TEMPLATE: exec <MOUNT_POINT> <EXECUTE_FILE> [...]

  local MOUNT_POINT=$1
  add_settings ${MOUNT_POINT}

  local RET=0
  set +e
  mv ${MOUNT_POINT}/etc/ld.so.preload ${MOUNT_POINT}/etc/ld.so.preload.temp-moved

  if [[ $# > 1 ]]; then
    local SCRIPT_NAME="$(basename $2).$(tr -dc 'A-F0-9' < /dev/urandom | dd bs=1 count=7 2>/dev/null)"
    local SCRIPT_PATH="/root/${SCRIPT_NAME}"

    cp "$2" "${MOUNT_POINT}/${SCRIPT_PATH}"
    my_echo "Running the script" "BLUE"
    chroot ${MOUNT_POINT} /bin/sh -c "${SCRIPT_PATH} ${@:3}" || RET=1
    rm "${MOUNT_POINT}/${SCRIPT_PATH}"
  else
    # https://wiki.archlinux.org/index.php/Change_root_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)
    # http://www.unix-lab.org/posts/chroot/
    # https://habrahabr.ru/post/141012/
    # https://losst.ru/vosstanovlenie-grub2
    # http://unixteam.ru/content/virtualizaciya-ili-zapuskaem-prilozhenie-v-chroot-okruzhenii-razmyshleniya
    # http://help.ubuntu.ru/wiki/%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_grub
    my_echo "Entering the chroot" "BLUE" \
    && chroot ${MOUNT_POINT} /bin/bash
  fi

  mv ${MOUNT_POINT}/etc/ld.so.preload.temp-moved ${MOUNT_POINT}/etc/ld.so.preload
  set -e
  return ${RET}
}

copy() {
  # TEMPLATE: copy <MOUNT_POINT> <MOVE_FILE> <MOVE_TO>

  local MOUNT_POINT=$1

  local dir_name=$(dirname "${MOUNT_POINT}$3 /")

  [[ ! -d ${dir_name} ]] && mkdir -p ${dir_name} \
  && my_echo "Created ${dir_name}" "GREEN"

  cp -r "$2" "${MOUNT_POINT}$3"
}

size() {
  # TEMPLATE: copy <IMG_PATH> <NEW_IMG_SIZE>

  IMG_PATH=$1
  NEW_IMG_SIZE=$2

  [ -e $IMG_PATH ] || (my_echo "The file path doesn't exist!" "RED"; exit 1)
  [ -f $IMG_PATH ] || (my_echo "The file path isn't a file! Now `size` utility doesn't support working with devices." "RED"; exit 1)

  # TODO: Check OS and current software
  # For example check macOS

  FDISK_INFO=$(fdisk -l ${IMG_PATH}) && echo -e "${FDISK_INFO}"
  # https://raspberrypi.stackexchange.com/questions/13137/how-can-i-mount-a-raspberry-pi-linux-distro-image
  # Or we can use: "parted -m $IMG_PATH unit B print free", but it have not DISKID
  # https://ru.wikipedia.org/wiki/Разрежённый_файл

  CUR_DISKID=$(echo -e "$FDISK_INFO" | sed -n 's/Disk identifier: 0x\([^ ]*\)/\1/p')

  LINUX_PART=$(echo -e "$FDISK_INFO" | tail -1 | grep Linux)
  [[ -z $LINUX_PART ]] && (my_echo "Linux partition is not at the end!" "RED"; exit 1)
  LINUX_PART_START=$(($(echo $LINUX_PART | awk -F' ' '{ print $2 }') * 512))
  LINUX_PART_END=$(($(echo $LINUX_PART | awk -F' ' '{ print $3 }') * 512))

  # Можно делать луп на 2ю партицию просто используя "${LOOPBACK}p2",
  # но тут проверочки и другие полезные данные
  LOOPBACK=`losetup -f` && losetup $LOOPBACK -o "$LINUX_PART_START" "$IMG_PATH"
  # https://www.stableit.ru/2011/05/losetup.html
  # -f     : losetup сам выбрал loop (минуя занятые) - отказался чтобы образ был размещен,
  # только на определенном раньше LOOPBACK (--show работает не везде)
  # --show : печатает имя устройства, например /dev/loop4
  # -P     : losetup монтирует разделы в образе как отдельные подразделы,
  #          например /dev/loop0p1 и /dev/loop0p2
  # ======================================================================
  # losetup can return smhtn like that ↓
  # losetup: os.img: Warning: file does not fit into a 512-byte sector; the end of the file will be ignored.
  # Change image size to 512B diveded size
  # https://stackoverflow.com/questions/26540693/how-do-i-read-write-a-block-device

  e2fsck -fy -v $LOOPBACK &> /dev/null || (my_echo "e2fsck changed the image. Maybe he is broken. Try again." "RED"; exit 1;)

  local LINUX_PART_MIN_SIZE=$(( $(resize2fs -P $LOOPBACK 2> /dev/null | awk -F': ' '{ print $2 }') * 4096 ))
  losetup -d "$LOOPBACK"

  local IMG_MIN_SIZE=$(($LINUX_PART_START + $LINUX_PART_MIN_SIZE + 512))
  local CUR_IMG_SIZE=$(($LINUX_PART_END + 512))
  local OBJ_IMG_SIZE=`du -sb $IMG_PATH | awk -F' ' '{ print $1 }'` # https://prowebmastering.ru/linux-uznat-razmer-papok-i-failov-v-terminale.html

  echo "IMG_MIN_SIZE: $IMG_MIN_SIZE"
  echo "CUR_IMG_SIZE: $CUR_IMG_SIZE"
  echo "OBJ_IMG_SIZE: $OBJ_IMG_SIZE"

  if [[ -n $NEW_IMG_SIZE ]]; then
      # FIXED:
      # losetup: os.img: Warning: file does not fit into a 512-byte sector; the end of the file will be ignored.
      DIVREMAINDER=$((${NEW_IMG_SIZE} % 512))
      if [[ $DIVREMAINDER -gt 0 ]]; then
          my_echo "The NEW_IMG_SIZE ($NEW_IMG_SIZE) does not fit in 512-byte sector (logic of losetup utility), autocorrect size." "BLUE"
          NEW_IMG_SIZE=$(($NEW_IMG_SIZE + 512 - $DIVREMAINDER))
      fi

      LINUX_PART_NEW_SIZE=$(($NEW_IMG_SIZE - $LINUX_PART_START - 512))
      echo "LINUX_PART_NEW_SIZE: $LINUX_PART_NEW_SIZE"
      # Кажется можно и не делать дробные сектора для увеличения размера раздела,
      # но ввиду нестабильности и постоянных статических ошибок,
      # а также для унификации кода сделал перерасчет LINUX_PART_NEW_SIZE и NEW_IMG_SIZE
      # с учетом 4096-байтового сектора в LINUX_PART
      DIVREMAINDER2=$((${LINUX_PART_NEW_SIZE} % 4096))
      if [[ $DIVREMAINDER2 -gt 0 ]]; then
          my_echo "The LINUX_PART_NEW_SIZE ($LINUX_PART_NEW_SIZE) does not fit in 4096-byte sector (logic of resize2fs utility), autocorrect size. And NEW_IMG_SIZE ($NEW_IMG_SIZE) too." "BLUE"
          LINUX_PART_NEW_SIZE=$(($LINUX_PART_NEW_SIZE + 4096 - $DIVREMAINDER2))
          NEW_IMG_SIZE=$(($LINUX_PART_START + $LINUX_PART_NEW_SIZE + 512))
      fi
      LINUX_PART_NEW_END=$(($LINUX_PART_START + $LINUX_PART_NEW_SIZE))

      echo "NEW_IMG_SIZE: $NEW_IMG_SIZE"
      echo "LINUX_PART_NEW_SIZE: $LINUX_PART_NEW_SIZE"
      echo "LINUX_PART_NEW_END: $LINUX_PART_NEW_END"

      # https://andreyex.ru/operacionnaya-sistema-linux/kak-sravnivat-chisla-v-bash
      [[ $NEW_IMG_SIZE -lt $IMG_MIN_SIZE ]] && (my_echo "The image size cannot be less then $IMG_MIN_SIZE" "RED"; exit 1)
      [[ $NEW_IMG_SIZE -eq $CUR_IMG_SIZE ]] && (my_echo "Nothing to do" "GREEN"; exit 1)

      # https://blog.eaglenn.ru/izmenenie-razmera-razdela-ext2-ext3-ext4-bez-poteri-informatsii/
      if [[ $NEW_IMG_SIZE -lt $CUR_IMG_SIZE ]]; then
          echo "MIN"

          LOOPBACK=$(losetup -f) && losetup -Pf $IMG_PATH
          resize2fs ${LOOPBACK}p2 $((LINUX_PART_NEW_SIZE / 4096))
          # Можно добавить параметр "-p" для отслеживания того, что делает программа.
          # Больше о параметрах здесь: http://man7.org/linux/man-pages/man8/resize2fs.8.html
          # Последним параметром указывается размер раздела,
          # если параметр не указан, то раздел увеличивается до последнего сектора устройства.

          sleep 1
          losetup -d $LOOPBACK

          parted $IMG_PATH rm 2
          parted $IMG_PATH unit B mkpart primary $LINUX_PART_START $LINUX_PART_NEW_END

          # https://linux.die.net/man/1/truncate
          truncate -s $(($LINUX_PART_NEW_END + 512)) $IMG_PATH
      else
          echo "MAX"

          truncate -s$NEW_IMG_SIZE $IMG_PATH

          parted $IMG_PATH rm 2
          parted $IMG_PATH unit B mkpart primary $LINUX_PART_START $LINUX_PART_NEW_END

          LOOPBACK=$(losetup -f) && losetup -Pf $IMG_PATH

          resize2fs ${LOOPBACK}p2 $((LINUX_PART_NEW_SIZE / 4096))
          sleep 1
          losetup -d $LOOPBACK
      fi

      # More information
      echo "================================================================================"
      parted -m $IMG_PATH unit B print free
      echo "================================================================================"

      mount_image ${IMG_PATH} fix_partuuid ${IMG_PATH} ${CUR_DISKID}
  fi
}

if [ $(whoami) != "root" ]; then
  echo ""
  echo "********************************************************************"
  echo "******************** This should be run as root ********************"
  echo "********************************************************************"
  echo ""
  exit 1
fi

get_version() {
  echo -en "$1: " && apt show $1 2>&1 | grep Version | gawk -F ': ' '{print $2}'
}

help() {
  my_echo "Use:" "BLUE"
  echo "img-tool <IMAGE> exec [ <SCRIPT> [...] ]"
  # TODO: Add ability executing commands from stdin
  echo "img-tool <IMAGE> copy <MOVE_FILE> <MOVE_TO>"
  echo "img-tool <IMAGE> size [ <NEW_SIZE> ]"
  echo "To minimize image:"
  echo "img-tool <IMAGE> size \$(img-tool <IMAGE> size | head -1 | cut -b 15-)"
  my_echo "Dependencies versions:"  "BLUE"
  get_version util-linux
  echo "losetup is using from util-linux"
  fsck
  truncate --version | head -n1
  chroot --version | head -n1
  resize2fs 2>&1 | head -n1
  get_version parted
}

echo "================================================================================"
for ((i=0; i<=$#; i++)); do echo "\$$i: ${!i}"; done
echo "================================================================================"

if [[ $# > 0 ]]; then

  [[ -e $1 ]] || (my_echo "$1 does not exist" "RED"; help; exit 1)

  if [[ -z $2 ]]; then help; else
    case "$2" in
      exec)
        mount_image $1 exec $3 ${@:4};;
      copy)
        mount_image $1 copy $3 $4;;
      size)
        size $1 $3;;
      *)
        help;;
    esac
  fi
else help
fi
